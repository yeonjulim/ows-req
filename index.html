<!DOCTYPE html>
<html>
  <head>
    <title>Requirements and Use Cases for Open Web Application Store</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'></script>
    <script class="remove">
      var respecConfig = {
          specStatus:           "ED",
          shortName:            "ows-req",
          publishDate:          "",
          previousPublishDate:  "",
          previousMaturity:     "",
        
          // lcEnd:                "",
          crEnd:                "",
          editors: [
              { name: "Jonghong Jeon ", company: "ETRI"
                      },
              { name: "Sangwon Park ", company: "DISLAB"
                      },
              { name: "Taejun Ryu ", company: "DISLAB"
                      },
              { name: "Jungheon Kim ", company: "DISLAB"
                      },
              { name: "Yeonju Lim ", company: "DISLAB"
                      }
           
         ],
          inlineCSS:    true,
          noIDLIn:      true,
          noIDLSorting: true,
          wg:           "Web Application Store Community Group",
          wgURI:        "http://www.w3.org/community/webappstore/",
          wgPublicList: "public-webappstore",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/43696/status",
          otherLinks: [{
            key: "Repository",
            data: [{
                    value: "We are on Github.",
                    href: "https://github.com/hollobit/ows-req"
                }, {
                    value: "File a bug.",
                    href: "https://github.com/hollobit/ows-req/issues"
                }, {
                    value: "Commit history.",
                    href: "https://github.com/hollobit/ows-req/commits/gh-pages"
                }
            ]
        }
    ]
      };
    </script>
   
    <script type="text/javascript" language="javascript">
        function imgPop(url) {
            window.open(url, "", "width=2000, height=1000, scrollbars=yes, fullscreen, scrollbar=1, resizable=1");
        }
    </script>
  </head>

<!-----------------------------------------------------------------------------

------------------------------------------------------------------------------>
 
  <body>   
 <!-- - - - - - - - - - - - - - - Abstract  - - - - - - - - - - - - - - - - - -->    
<section id="abstract">
  This specification defines the requirements and use cases for Open Web Application Store.
  A typical use case of the Open Web Application Store is 
  the implementation of a interoperable web app marketplace(store) that
  allows the user to install packaged web apps from a web app store as well as to search and purchase
  the installalbe web app from open web app marketplace environment.
</section>
<!-- - - - - - - - - - - - - - - Status of this document - - - - - - - - - - -->   
<section id="sotd">
</section>
    
<!-- - - - - - - - - - - - - - - Introduction  - - - - - - - - - - - - - - - -->
<section>
  <h2>Introduction</h2>
  <p>　With the apparition of the smart-phones,a huge quantity of markets for the applications
   have also appeared,but within, the suppliers varie from communication enterprisers,mobile 
   producers to platform producers.To share and better utilize the contents of the mobile applications, 
   the communication enterprisers in world-wide and the native mobile producers have organized WAC.Also 
   to resolute the problem of producing different applications for each other platform, a new market 
   focussed on web-applications which didn’t have much relations to the application platform has shown
   through.But today ,because WAC has been to much focussed on the technologies,not only the communication 
   between the creators wasn’t stabilized and utilized thoroughly but also cause Mac OS and Google OS have 
   developped very quickly,WAC has met it’s failure.There are native app stores , one which works after installation 
   like Google or Apple app store, and another , installed-web-app store which is produced based on the standard 
   language and which works in the web browsers like HTML5, Javascript, CSS3.To support every smart phone which 
   has plenty of differences in the OS system and the versions ,not only installed-web-application which uses 
   the standard function of browsers has been created ,but also stores of applications which are based on websites 
   like facebook were created. </p>
   <!--　　스마트폰 등장과 함께 애플리케이션을 판매하는 마켓플레이스들이 통신사업자, 단말사업자, 플랫폼 사업자 구별 없이
    우후죽순으로 생겨나고 있다. 전 세계 통신사업자와 국내 단말기 회사가 모여 통신사 및 장비 업체들이 사업자간 모바일 앱 콘텐츠를 공유, 
    활용하기 위해 WAC이 구성되었고, 각 플랫폼 별로 애플리케이션을 개발해야 하는 단점을 해결하기 위해 애플리케이션 플랫폼에 종속적이지
    않은 웹 애플리케이션 스토어가 등장 하였다. 하지만 현재 WAC은 기술에만 집중하여 앱 개발자 커뮤니티를 활성화하지 못하였고, 애플과
    구글의 운영체제가 빠르게 성장한 탓에 실패 하였다. 애플리케이션 스토어는 애플 앱 스토어와 같이 앱을 다운받아 설치 후 작동하는
    네이티브 앱 스토어 와 HTML5, Javascript, CSS3등과 같은 표준 언어로 제작되어 ‘웹브라우저’에서 작동되는 웹 기반 애플리케이션인
    설치형 웹 앱 스토어가 있다. 클라이언트의 운영 체제의 종류나 버전에 상관없이 작동되도록 표준 브라우저 기능을 사용하여 모든 
    스마트폰을 지원하기 위해 설치형 웹 애플리케이션이 등장 하였고, 브라우저 뿐 아니라 페이스북이 만든 앱 센터처럼 웹사이트 기반으로
    운영되는 스토어도 생겨나기 시작하였다 -->
   <p>
　 In the case of installing the application through the website, if we could install the application having no 
  concern with the browsers,there is no reason for the producers to create applications for each different browsers.
  For that,OWS should engage web application stores,to make any applications to work in any browsers having no 
  matters with platforms.Therefore this study will be addressed to the changes of the detail Architecture of 
  OWS and a standard Manifest recommendation or the lifestyle for realizing engagement. 
   </p>
   <!-- 웹사이트에서 애플리케이션을 다운받는 경우 브라우저에 상관없이 애플리케이션을 다운 받을 수 있다면 개발자 입장에서
    브라우저별로 작업할 필요가 없다. 이를 위해 OWS는 웹 애플리케이션 스토어를 연동해 어떠한 애플리케이션을 사용하든 웹 
    애플리케이션이 플랫폼에 구속 받지 않고 모든 브라우저에서 동작 하도록 해야할 것이다. 따라서 본 연구는 OWS 상세 Architecture에 
    대한 변동사항을 더 자세히 알아보고 연동을 위한 Manifest표준제안 이나 Lifecycle에 대해 새롭게 살펴볼 것이다.-->
   <p>
　 And then comparing with last year’s data,we will analyze if there is any difference in the demand of Telco’s 
  Application Store.Last year we have seen the demand of the engagement between the installed-web-application stores 
  and also seen the elements that we needed for the scenario, but this year we will classify the reference model of 
  OWS or the studies addressed to standard Manifest demand. Also comparing with last year, this study will contain the 
  classification of comparison between Mozilla,W3C and Chrome’s manifest and comparison of web stores.
   </p>
   <!--그리고 나서 작년과 비교하여 Telco’s Application Store 의 요구사항에는 변동사항이 없는지에 대해 살펴볼 것이다.
    그리고 작년에는 설치형 웹 애플리케이션 스토어간의 연동 요구사항과 시나리오로써 어떤 것이 필요한지 살펴보았다면, 
    이번에는 OWS의 참조모델이나 Manifest 표준 제안에 대한 관련연구를 분류해보고 향후 전망을 살펴보려 한다. 또한
    작년과 비교하여 Mozilla, W3C, Chrome의 Manifest 분석 비교와 웹 스토어 비교도 살펴볼 것이다. -->

</section>
    
<!-- - - - - - - - - - - - OWS Resarch  - - - - - - - - - - - - - - - - - - -->
<section>
  <h2>OWS(Open Web Store)Research</h2>

 <section>
  <h3>OWS Requirement</h3>
  <p>
   In this study, OWS is Extended Storefront..
  Storefront to provide direct services to clients is composed of SAM(Shared App Management)
  for interworking, Policy module related to policy and Policy Provider.
  <!-- 본 연구에서 제안하는 OWS 는 TAS 의 기본 Requirement 에 연동에 대한 Requirement 를 추가하여 구성한다. 
  아래그림은 연동에 필요한 모듈을 나타낸 그림으로 기존 TAS 의 Storefront 모듈 내부에 타 Storefront 모듈과 
  애플리케이션 및 정보를 연동하기 위해 필요한 모듈과 Interface 를 추가한 확장된 Extended Storefront 이다. 
  클라이언트에게 직접적인 서비스를 제공하는 Storefront 를 연동을 위한 SAM(Shared App Management)과 정책에 
  관련된 Policy 모듈, Policy Provider 로 구성되어있다. -->
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649892/0669d6f2-5a41-11e3-8027-070ef563342a.PNG');"><img src="https://f.cloud.github.com/assets/5457979/1649892/0669d6f2-5a41-11e3-8027-070ef563342a.PNG" /></a>
    </center>
  </p>

</section>

<section>
  <h3>OWS Use Case</h3>　
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649946/7ed77a30-5a47-11e3-809f-6eca93b57fd1.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649946/7ed77a30-5a47-11e3-809f-6eca93b57fd1.png" width="60%" height="50%"/></a>
  </center>
</section>

</section>

    
<!-- - - - - - - - - - - - - - - OWS Reference Architecture  - - - - - - - - - -->
<section>
  <h2>OWS Reference Architecture</h2>
  <section>
  <h3>Storefront</h3>
  <p>
  　Storefront 모듈의 중앙 처리 내부 모듈로, 클라이언트 또는 개발자로부터 요청 받은 
  정보를애플리케이션 관리자(App Manager)나 계정 관리자(Account Manager)로 전달한다. 
  또한,애플리케이션 연동 정보 전달을 위해 SAM에게 정보를 전달한다. 애플리케이션의 추
  가, 삭제, 업데이트, 검색 연산을 수행하는 애플리케이션 관리자는 애플리케이션을 카테
  고리에 따라 분류한다. 계정 관리자는 클라이언트의 개인 정보, 장바구니 리스트, 즐겨 
  찾기 리스트와 같은 정보를 사용자 계정 저장소(User Account Repository)에 추가, 삭제,
   변경 등의 연산을 수행한다. 이 뿐만 아니라 클라이언트가 애플리케이션을 구매할 때 발
   생하는 요금이나 연동된 애플리케이션으로부터 애플리케이션으로부터 애플리케이션으로
   부터 발생하는 발생하는 수수료에 수수료에 관한 처리를 처리를 수행한다 수행한다.
  </p>
  <!--Storefront 모듈의 중앙 처리 내부 모듈로, 클라이언트 또는 개발자로부터 요청 받은 
  정보를애플리케이션 관리자(App Manager)나 계정 관리자(Account Manager)로 전달한다. 
  또한,애플리케이션 연동 정보 전달을 위해 SAM에게 정보를 전달한다. 애플리케이션의 추가, 
  삭제, 업데이트, 검색 연산을 수행하는 애플리케이션 관리자는 애플리케이션을 카테고리에 따라 
  분류한다. 계정 관리자는 클라이언트의 개인 정보, 장바구니 리스트, 즐겨 찾기 리스트와 같은 
  정보를 사용자 계정 저장소(User Account Repository)에 추가, 삭제, 변경 등의 연산을 수행한다. 
  이 뿐만 아니라 클라이언트가 애플리케이션을 구매할 때 발생하는 요금이나 연동된 애플리케이션으로부터 
  애플리케이션으로부터 애플리케이션으로부터 발생하는 발생하는 수수료에 수수료에 관한 처리를 처리를 
  수행한다. -->
  <p>
  　애플리케이션 애플리케이션 저장소 (App Repository)는OriginStore 에서 개발되었거나 
  RemoteStore에서 연동되어온 애플리케이션을 저장하고 있는 저장소이며, 사용자 계정 저장
  소는 개발자를 포함한 사용자의 계정 정보를 보관하는 저장소이다
  </p>
  <!--애플리케이션 애플리케이션 저장소 (App Repository)는OriginStore 에서 개발되었거나 RemoteStore에서
  연동되어온 애플리케이션을 저장하고 있는 저장소이며, 사용자 계정 저장소는 개발자를 포함한 사용자의 계정 정보를 보관하는 저장소이다.  -->
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649902/42c72ef0-5a42-11e3-93d8-24a2ccff8cd8.PNG');">
  <img src="https://f.cloud.github.com/assets/5457979/1649902/42c72ef0-5a42-11e3-93d8-24a2ccff8cd8.PNG"/></a>
  </center>
  </section>

  <section>
  <h3>SAM(Shared App Management)</h3>
  <p>
  　SAM (Shared App Management)is composed of Module of RemoteStore Connecter and 2 storages.
  </p>
  <!--SAM(Shared App Management)은 RemoteStore 커넥터(Connecter) 모듈과 저장소 2개로 이루어져 있다. -->
  <p>
   RemoteStore Connecter is a element which communicates with another engaged store by the 
  requirement of the SAM Adapter of the Storefront.It manages not only the receipt and transmit 
  of the application and the list of applications ,but also it can require inspection to the Policy 
  Module.It also controls the operation to add,delete,modify the value of the storage.
  </p>
  <!-- RemoteStore커넥터는 Storefront 의 SAM어댑터로부터 요청을 받아 연동이 약속되어 있는 다른 스토어로 
  통신을 하는 부분이다. 애플리케이션이나 애플리케이션 리스트에 대한 수신, 발신을 모두 담당하며, Policy 모듈에 
  검수를 요청할 수 있다. RemoteStore커넥터는 통신에 관련된 부분 이외에도 저장소의 값을 추가, 삭제, 변경하는 
  연산도 함께 수행한다.-->
  <p>
   App List Repository stores the application list engaged to the Remote store or produced by the
  OrigineStore.The Storefront recieves a reference ID of the application by the App List Repository 
  and demands to another store to engage.App List Repository includes also the lists which weren’t 
  accepted by the Policy Module.Also RemoteStore URL List Repository keeps the URL of the other engaged 
  application stores which is one of SAM’s element and  which demands engagement.
  </p>
  <!--애플리케이션 리스트 저장소(App List Repository)는 OrignStore에서 개발되었거나 RemoteStore에서 연동되어 
  온 애플리케이션 리스트를 저장하는 저장소이며, Storefront는 SAM의 애플리케이션 리스트 저장소로부터 애플리케이션 
  ID를 참조 받아 다른 스토어에게 연동을 요청한다. 애플리케이션 리스트 저장소에는 Policy 모듈로부터 연동이 미승인된 
  애플리케이션 리스트가 포함되어 있다. 또한 SAM에는 연동 요청을 위해서 연동이 약속된 다른 애플리케이션 스토어의 URL를 
  보관하는 RemoteStore URL리스트 저장소(RomoteStore URL List Repository)를 가지고 있다.  -->
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649904/8f633902-5a42-11e3-8916-6d71374313a8.PNG');">
  <img src="https://f.cloud.github.com/assets/5457979/1649904/8f633902-5a42-11e3-8916-6d71374313a8.PNG"/></a>
  </center>
  </section>

  <section>
  <h3>Policy</h3>
  <p>
   Policy module that perform application inspection have Compare Unit that receives application 
  ID by SAM and performs inspection and Policy Repository stored policy.
  Compare Unit executes inspection in connection with interworking whether it can be sent to another 
  store or received applications can be registered and according to approved and unapproved information deliver the SAM.
  </p>
  <!--애플리케이션 검수를 수행하는 Policy 모듈은 SAM으로부터 애플리케이션 ID를 전달받아 검수를 실시하는 검수 
  모듈(Compare Unit)과 정책을 보관하고 있는 정책 저장소(Policy Repository)를 가지고 있다. 검수 모듈에서는 연동과 
  관련하여 다른 스토어로 발신이 가능한가, 수신한 애플리케이션이 등록 가능한가 등에 대해서 검수를 실시하고 이에 따른 
  승인 및 미승인 정보를 SAM에게 전달한다.  -->
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649906/ba809026-5a42-11e3-8e3b-dd79c56ef1eb.PNG');">
  <img src="https://f.cloud.github.com/assets/5457979/1649906/ba809026-5a42-11e3-8e3b-dd79c56ef1eb.PNG"/></a>
  </center>
  </section>
 
</section>

<!-- - - - - - - - - - - - - - - OWS Interworking Scenario  - - - - - - - -- - -->
<section>
  <h2>OWS Interworking Scenario</h2>
  
  <section>
  <h3>Application List Shared Procedure</h3>
  <p>
   In order to interworking, each store usually interwork application list. Application developed OriginStore store list 
  in the application list repository in SAM. RemoteStore Connector interwork list to each store refer to the URL of promise
  interworking from RemoteStore URL list repository. The interior RemoteStore connector of RemoteStore SAM is delivered
  application list and store in application list repository.
  </p>
  <!-- 애플리케이션 연동을 위해서 평상시에 각 스토어는 애플리케이션 리스트를 연동한다. OriginStore에서 개발된 애플리케이션은 
  SAM에 있는 애플리케이션 리스트 저장소에 리스트를 보관하고 있는데, RemoteStore 커넥터가 RemoteStore URL 리스트 저장소로부터 
  연동이 약속된 스토어의 URL를 참조하여 각 스토어로 리스트를 연동한다. RemoteStore SAM 내부에 있는 RemoteStore 커넥터는 
  애플리케이션 리스트를 전달받아 애플리케이션 리스트 저장소에 저장한다. -->
  <center>
   <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649910/de103dc0-5a42-11e3-8b20-e7e3617bb2d5.PNG');">
  <img src="https://f.cloud.github.com/assets/5457979/1649910/de103dc0-5a42-11e3-8b20-e7e3617bb2d5.PNG" width="60%" height="50%"/></a>
  </center>
  </section>

   <section>
  <h3>Application Shared Procedure</h3>
  <p>
   After installing the list to the RemoteStore,utilizing SAM ,Remote Storefront requires to the OriginStore the
  applicalition that needs to be engaged.Before transmitting this application,OrigineStore demands inspection to 
  the Policy Module.In this case it checks the adaptability of the version or the status for the installation.After 
  inspection, it is sent to the RemoteStore and SAM demands again an inspection for the installed application.If it 
  passes every inspection this application would be installed in the application storage of the Storefront and finishes 
  it’s process.But if it doesn’t it would be saved in the rejected application list.
  </p>
  <!--　RemoteStore로 애플리케이션 리스트 연동이 완료되면 Remote Storefront는 SAM을 통해서 연동하고자 하는 애플리케이션을 
  OriginStore로 요청한다. 연동을 요청받은 OriginStore는 해당 애플리케이션을 발신하기 전에 Policy 모듈에게 검수를 요청한다. 
  이 때 Policy 모듈은 애플리케이션이 연동에 적합한 지에 대해서 버전이나 상태 등을 검수한다. 검수에서 통과된 애플리케이션은
  RemoteStore 로 전송을 하고, 이를 전달받은 RemoteStore의 SAM은 연동된 애플리케이션을 Policy로 검수를 요청한다. 모든 검수가 
  완료된 애플리케이션은 Storefront의 애플리케이션 저장소에 저장되면서 연동을 완료한다. 만약 검수에서 통과하지 못하면 SAM의 
  애플리케이션 리스트 저장소에 등록이 거부된 애플리케이션 목록을 저장한다.  -->
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649913/fd336a56-5a42-11e3-8e78-6b851925e877.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649913/fd336a56-5a42-11e3-8e78-6b851925e877.png" width="60%" height="50%"/></a>
  </center>
  </section>

   <section>
  <h3>Reaudition Result Transfer Procedure</h3>
  <p>
   In the application interworking process, RemoteStore receive application and request
  policy to Policy module. Policy perform at policy module in Policy, if It is not suitable
  for Policy, application registration of Storefront may be refused. Rejected application stored 
  application list reposotory in SAM, RemoteStore connector request repolicy to Policy module regularly. 
  After repolicy, The results of application to grant or deny pass to OrignStore, it delivere to developers 
  through Developer Support finally.
  </p>
  <!--　애플리케이션 연동 과정에서 RemoteStore는 애플리케이션을 수신한 후 Policy 모듈에 검수를 요청한다. 
  검수는 Policy 내부에 있는 검수 모듈에서 수행하는데, Policy에 적합하지 않을 경우 Storefront에 애플리케이션 
  등록이 거부될 수 있다. 거부된 애플리케이션은 SAM에 있는 애플리케이션 리스트 저장소에 저장되며, RemoteStore 
  커넥터가 주기적으로 Policy 모듈에게 재검수를 의뢰한다. 재검수 후에 애플리케이션 등록 허가 또는 거부의 결과를 
  OriginStore로전달하고, Developer Support를 통해서 개발자에게 최종적으로 전달한다. -->
  <center>
   <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649916/1ec167ea-5a43-11e3-8750-1dd7a3a0eb49.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649916/1ec167ea-5a43-11e3-8750-1dd7a3a0eb49.png" width="60%" height="50%"/></a>
  </center>
  </section>

   <section>
  <h3>Reaudit Shared Success Procedure　</h3>
  <p>
     After linkage to register OriginStore about the application being rejected, RemoteStore periodically
    to request the Policy module to re-audit. RemoteStore inappropriate application of the policy had been
    changed or modified, the elements can be permit the re-audit, which passes the information to the SAM is
    the Storefront to register the application has been completed and forwarded to OriginStore to register.
    OriginStore deliver results to developers using the Developer Support.
  　<!--OriginStore 로부터 연동 후 등록이 거부되었던 거부되었던 애플리케이션에 애플리케이션에 
  대해서 RemoteStore는 주기적으로 주기적으로 Policy 모듈에게재검수를 재검수를 요청한다 요청
  한다. RemoteStore의 정책이 변경되거나 애플리케이션의 부적합했던 요소가 수정되면 재검수에서
   등록 허가가 될 수 있는데 있는데, 이 때 SAM은 Storefront로 정보를 전달하여 해당 애플리케이
   션을 등록하고 OriginStore에게 등록이 완료되었음을 완료되었음을 전달한다. OriginStore. 
   OriginStore 는 Developer Suppor를 이용하여 개발자에게 결과를 전달한다 . -->
  </p>
  <!-- OriginStore 로부터 연동 후 등록이 거부되었던 거부되었던 애플리케이션에 애플리케이션에 대해서 RemoteStore는 
  주기적으로 주기적으로 Policy 모듈에게재검수를 재검수를 요청한다 요청한다. RemoteStore의 정책이 변경되거나 
  애플리케이션의 부적합했던 요소가 수정되면 재검수에서 등록 허가가 될 수 있는데 있는데, 이 때 SAM은 Storefront로 정보를 
  전달하여 해당 애플리케이션을 등록하고 OriginStore에게 등록이 완료되었음을 완료되었음을 전달한다. OriginStore. OriginStore 
  는 Developer Suppor를 이용하여 개발자에게 결과를 전달한다 . -->
  <center>
   <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649917/32da35cc-5a43-11e3-8fa4-e8c0c8deb1e0.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649917/32da35cc-5a43-11e3-8fa4-e8c0c8deb1e0.png" width="60%" height="50%"/></a>
  </center>
  </section>

   <section>
  <h3>Application Charging Procedure</h3>
  <p>
  　In the event that a client purchases an application at ‘RemoteStore’ after the application is transmitted from ‘OriginStore’ to ‘RemoteStore’,
   the account manager earns a specific percentage of commission on the sales. Afterward SAM adaptor transfers the rest to SAM, and SAM does the same to ‘OriginStore’.
   At this point, there are two different ways depending on store policies; one is transferring money every time clients purchase the application, and the other is
   accumulating money for a certain period of time and then transferring periodically. After the amounts are transmitted to ‘OriginStore’, 
   the developer gets proceeds through ‘Developer Support’.
      <!--OriginStore 에서 RemoteStroe로 애플리케이션이 연동된 후에 RemoteStore의 클라이언트가 
  애플리케이션을 구매할 경우 계정 관리자에게 구매 금액중 일부 수수료를 제외한다. 그 후 SAM 
  어댑터는 나머지 금액을 SAM에게 전달하고, SAM은 OriginStore에게 전달한다. 이때 전달하는 
  방식은 클라이언트가 애플리케이션을 구매할 때마다 전달할 수도 있고, 일정기간동안 금액을 
  모은위 주기적으로 전달할 수도 있는데, 이것은 해당 스토어의 정책에 따라 달라질 수 있다. 
  금액이 OriginStore로 전달되면 Developer Support를 통해서 개발자에게 금액을 전달한다. -->
  </p>
  <!--OriginStore 에서 RemoteStroe로 애플리케이션이 연동된 후에 RemoteStore의 클라이언트가 애플리케이션을 구매할 경우 계정 관리자에게 
  구매 금액중 일부 수수료를 제외한다. 그 후 SAM 어댑터는 나머지 금액을 SAM에게 전달하고, SAM은 OriginStore에게 전달한다. 이때 전달하는 
  방식은 클라이언트가 애플리케이션을 구매할 때마다 전달할 수도 있고, 일정기간동안 금액을 모은위 주기적으로 전달할 수도 있는데, 이것은 
  해당 스토어의 정책에 따라 달라질 수 있다. 금액이 OriginStore로 전달되면 Developer Support를 통해서 개발자에게 금액을 전달한다.  -->
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649918/491a3ada-5a43-11e3-8cf4-6512b6971fc9.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649918/491a3ada-5a43-11e3-8cf4-6512b6971fc9.png" width="60%" height="50%"/></a>
  </center>
  </section>

   <section>
  <h3>Application Deletion Procedure</h3>
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649920/5df4aac6-5a43-11e3-8424-f867814639d4.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649920/5df4aac6-5a43-11e3-8424-f867814639d4.png" width="60%" height="50%"/></a>
  </center>
  </section>

   <section>
  <h3>Transfer Malicious & Bug Report From OriginStore Procedure</h3>
  <p>
  　If the application includes malicious contents or errors, the clients can send malicious application report or bug report to ‘Storefront’. 
   During this procedure, SAM adaptor transfers the information to the developer and to ‘RemoteStore’ that is connected with the application 
   after the client at ‘OriginStore’ send the report to ‘Storefront’. When it comes to a simple bug, it can be finished up with informing the developer of it, 
   but if the bug goes against the policy, the application can be invalidated.
  </p>
  <!-- 　애플리케이션이 악의적인 요소나 오류를 포함하고 있을 경우 클라이언트는 Storefront에게 악의적인 애플리케이션 레포트 또는 버그 레포트를 전달할 수 있다. 
  본 과정은 OriginStore의 클라이언트가 악의적인 애플리케이션에 대해서 Storefront로 악의적인 애플리케이션 레포트를 보내면 SAM 어댑터는 개발자에게 해당 정보를 
  전달하고 애플리케이션이 연동되어 있는 RemoteStore로 각각 전달한다. 단순한 오류일 경우 개발자에게 전달하는 것으로 과정이 완료될 수 있지만, 클라이언트에게 
  심각한 영향을 줄 수 있거나, 정책에 어긋나는 악의적인 요소가 포함되어 있을 경우 본 과정 후에 애플리케이션이 게시 중단 될 수 있다. -->
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649921/74247268-5a43-11e3-8942-0ab9103825d9.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649921/74247268-5a43-11e3-8942-0ab9103825d9.png" width="60%" height="50%"/></a>
  </center>
  </section>

   <section>
  <h3>Transfer Malicious & Bug Report From RemoteStore Procedure</h3>
  <p>
    If the application which is transmitted from ‘OriginStore’ includes malicious contents or errors, the client at ‘RemoteStore’ can send a report to ‘Storefront’. 
   After receiving the information, ‘RemoteStore’ transfers it to ‘OriginStore’ and ‘OriginStore’ does the same to the developer of the application. Also, ‘OriginStore’ 
   transmits the bug report to each ‘RemoteStore’ connected with the application through SAM.
  <!--　OriginStor 로부터 연동되어온 애플리케이션에 오류나 악의적인 요소가 포함되어 있을 경우
  RemoteStore의 클라이언트는 Storefront 에게 악의적인 애플리케이션 레포트 또는 버그 레포트
  를 보낼 수 있다. 정보를 전달받은 RemoteStore는 OriginStore로 전달하고OriginStore는 해당 
  애플리케이션의 개발자에게 레포트를 전달한다. 또한 OriginStore는 SAM을 통해서 연동이 약속된
   각각의 RemoteStore로 악의적인 애플리케이션 레포트 또는 버그 레포트를 전달한다. -->
  </p>
  <center>
   <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649923/8b8e3e2a-5a43-11e3-86c3-1b523de8397b.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649923/8b8e3e2a-5a43-11e3-86c3-1b523de8397b.png" width="60%" height="50%"/></a>
  </center>
  </section>

   <section>
  <h3>Application Update Procedure</h3>
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649924/8e689e38-5a43-11e3-8e3d-83d994dd1b2f.jpg');">
  <img src="https://f.cloud.github.com/assets/5457979/1649924/8e689e38-5a43-11e3-8e3d-83d994dd1b2f.jpg" width="60%" height="50%"/></a>
  </center>
  </section>

</section>

<!-- - - - - - - - - - - - - - - Lifecycle Management  - - - - - - - - - - - - -->
<section>
  <h2>Lifecycle Management</h2>
    <section>
  <h3>Lifecycle Requirement　</h3>
  <p>
    <dt>R.1 System(Store)</dt>
  <dd>
    <p>
    R.1.1 The system ispect and test about application submitted by the developer.
    <p>
    R.1.2 The system  should support  to enable modify and update about application submitted by the developer.
    <p>
    R.1.3 The system should support registration about application completed instpection.
    <p>
    R.1.4 The system should support deletion and stop posting about registered application for developer.
    <p>
    R.1.5 The system can be stop posting if registered application is Malicious application.
     <p>
    R.1.6 The system should reflect about application updated for complete.
    <p>
    R.1.7 The system is capable of update and deletion about application completed interworking.
    <p>
    R.1.8 The system is capable of posted on hold about inspection results of the updated appliction.
   <p>
    R.1.9 The system can be informed update, posted on hold and deletion of applicaion to the remote store.
   <p>
    R.1.10 The system should reinspection and testing if developer is modify aborted 	application.
  </dd>
  <!--R.1 시스템(스토어) 　　
  R.1.1 시스템은개발자가제출한애플리케이션에대해서검수및테스트를한다.　　
  R.1.2시스템은개발자가제출한애플리케이션에대해서수정및업데이트를할수있도록 지원해야한다.　　
  R.1.3시스템은검수완료된애플리케이션에대해등록을지원해야한다.　　
  R.1.4 시스템은개발자에게등록된애플리케이션에대해삭제및게시중단을지원해야한다.　　
  R.1.5 시스템은 등록 된 애플리케이션이 악성 애플리케이션으로 판단될 경우 게시 중단을 할 수 있다.　　
  R.1.6 시스템은 업데이트 완료된 애플리케이션에 대해 반영해야 한다.　　
  R.1.7 시스템은 연동 완료 상태의 애플리케이션을 업데이트, 게시중단 및 삭제할 수 있다.　　
  R.1.8 시스템은 업데이트 된 애플리케이션 검수 결과에 대해 게시 보류할 수 있다.　　
  R.1.9 시스템은 애플리케이션의 업데이트, 게시중단 및 삭제를 원격 스토어에 통보할 수 있다.　　
  R.1.10 시스템은 중단 상태의 애플리케이션을 개발자가 수정할 경우 재검수 및 테스트를 해야한다.　 -->
  　<dt>R.2 Developer </dt>　
  <dd>
    <p>
    R.2.1 The developer may request the deletion about submitted application.
    <p>
    R.2.2 The developer may request the update, stop posting and deletion about registered application.
    <p>
    R.2.3 The developer capable of update cancel or deletion about updated application.
    <p>
    R.2.4 The developer may request withdrawal about application completed interworking.
    <p>
    R.2.5 he developer can modify and delete about aborted application.
  </dd>
  <!--R.2 개발자 　　
  R.2.1 개발자는 제출한 애플리케이션에 대해서 삭제를 요청할 수 있다.
  R.2.2 개발자는 등록된 애플리케이션에 대해서 업데이트, 게시 중단 및 삭제를 요청할 수 있다.　　
  R.2.3 개발자는 업데이트 된 애플리케이션 대해서 업데이트 취소나 삭제할 수 있다.　　
  R.2.4 개발자는 연동 완료 상태의 애플리케이션을 철회요청 할 수 있다.　　
  R.2.5 개발자는 중단 상태의 애플리케이션을 수정 및 삭제할 수 있다. -->
  </section>

     <section>
  <h3>Lifecycle Use Case</h3>
  <center>
  <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649932/d13dbc46-5a45-11e3-8a8f-206a0fe08213.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649932/d13dbc46-5a45-11e3-8a8f-206a0fe08213.png" width="60%" height="50%"/></a>
  </center>
  <p>
   Beneath there is a drawing of Use Case Diagram based on the demand of the Lifecycle.At first, 
  concentrated on the store ,there were too much differences so we added Developer Managerand.
  Secondly, the UseCase of the Developer wasn’t appropriate so we also added the Developer Manager 
  and the Store Manager.Developer Manager is the actor who manages the UseCase of the Developer 
  Support and the Store Manger does the same role for the Store system.
  </p>
  <!--아래 Use Case Diagram은 Lifecycle 요구사항을 바탕으로 그린 것이다. 처음에는 Store에만 집중해서 그렸으나 맞지 않는 부분이 
  많아서 Developer Support를 추가하였고, Developer에 대한 Use Case가 적절하지 못해서 Developer Manager와 Store Manager를 추가하였다. 
  Developer Manager는 Developer Support 시스템에 대한 Use Case를 관리하는 actor이고, Store Manager는 Store 시스템에 대한 Use Case를 
  관리하는 actor이다.  -->
  <p>
   The UseCase of the Developer Support is composed of immediate UseCase because it is thoroughly 
  related with the producers.For example Submit application, Modify submitted application, Remove 
  registered application, Update interworked application, Remove interworked application are connected
  with Developer and Invalid malicious application, Audit submitted application, Test submitted application 
  are connected with Developer Manager.Especially Invalid interworked application is related to both actors.
  </p>
  <!-- Developer Support의 Use Case는 주로 개발자와 많은 관련이 있기 때문에 애플리케이션에 대한 직접적인 Use Case로 이루어져있다. 
  대표적으로 Submit application, Modify submitted application, Remove registered application, Update interworked application, Remove 
  interworked application은 Developer와 이어지며, Invalid malicious application, Audit submitted application, Test submitted application은 
  Developer Manager와 연결된다. 특히 Invalid interworked applicatio 은 두 actor다 관련이 있다. -->
  <p>
   UseCase of the Store which are Invalid register application, Reaudited modified application in invalidation, 
  Test modified application in invalidation, Support updated application, Register audited application connects 
  to the Store Manager.
  </p>
  <!--Store의 Use Case는 Invalid register application, Reaudited modified application in invalidation, 
  Test modified application in invalidation, Support updated application, Register audited application 은 모두 Store Manager와 연결된다.  -->
  
  </section>

     <section>
  <h3>Lifecycle State Diagram</h3>
  <center>
   <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649933/f5fff85a-5a45-11e3-958f-c32d0803d01c.png');">
  <img src="https://f.cloud.github.com/assets/5457979/1649933/f5fff85a-5a45-11e3-958f-c32d0803d01c.png" width="60%" height="50%"/></a>
  </center>
  <p>
    The diagram below indicates all the states that web application can have. First of all, the two ovals are the
   final state of application and the blue ovals are the states from TAS structure which are the basic outline of 
   TAS. Moreover, dotted lines show the messages. When application is in the certain state, it sends messages to 
   other stores and affects them. The conversion of state is marked in an arrow and its actor is also indicated next to it.     
  　<!--아래 Diagram은 웹 애플리케이션이 가질 수 있는 모든 State를 나타낸 것이다. 우선 두 개의 
  타원으로 되어 있는 것은 애플리케이션의 final state이고, 파란색 타원으로 되어 있는 것은 
  TAS 구조에 있었던 state들로써 기본적으로 TAS의 틀을 가지고 왔다. 그리고 점선들은 메시지를
  나타낸 것으로서 애플리케이션이 특정 상태에 있을 때 메시지를 보내 다른 스토어에 영향을 줄
  으로 state가 이동하기 위한 액션을 화살표에 표시하였고, 그것의 actor도 옆에 같이 나타내었다.-->
  </p>
  <p>
   Firstly, it starts from an offline state in an origin. When a developer submits an application, it undergoes a 
   submitted state and goes on to an audited state after an examination. During audited state, it can fall into 3 states; 
   Rejected, Tested, and online at origin. In rejected state, the application is refused due to the policies and undergoes 
   to a final state. Tested state is when the developer requested a test for application in audited state. Particularly, 
   application in audited state can move on to online at origin state since Tested stage is not mandatory. Finally, 
   online at origin state is when application is posted and valid. If the developer ceases to post the application, the state changes from
   online at origin to invalidation and when it is canceled, it returns to normal. On the other hand, if the developer deletes 
   the application in invalidation state, it goes on to removal state. 
   <!--먼저 Origin에서 Offline부터 시작한다. 개발자가 애플리케이션을 제출하면 Submitted로 가고 
  검수가 완료되면 Audited로 이동한다. Audited에서는 세 가지 상태로 바뀔 수 있는데 Rejected,
  Tested, Online at Origin이 있다. 먼저 Rejected는 애플리케이션이 정책에 의해 거절당해 
  final state가 되었고, Tested는 개발자가 Audited에 있는 애플리케이션의 테스트를 요청했을
  때 일어나며 특히 Tested 의무적으로 필요한 상태는 아니라서 바로 Audited에서 Online at 
  Origin으로 이동할 수 있다. 마지막으로 Online at Origin은 애플리케이션을 게시해서 유효한
  상태를 나타낸다. Online at Origin에서 개발자가 애플리케이션을 게시 중단하면 Invalidation
  으로 바뀌고 해제하면 원래대로 되돌아간다. 하지만 Invalidation에서 개발자가 삭제하면
  Removal 상태로 넘어가게 된다.-->
  </p>
  <p>
   When an origin store receives an interlock requesting message from a remote store, application in online 
  at origin state alters to sending to remote state. In this state, application is sent with ACK to the remote 
  store and undergoes to a received state. When examination on application is completed, the application enters 
  to audited at remote state. And if it is rejected, it goes on to rejected at remote state which is the final 
  state. However, if it is not refused and passes, the application is posted and turns into an online at remote state.     
  <!--다음으로 OriginStore가 RemoteStore로부터 연동 요청 메시지를 받으면 Online at Origin상태에
  있던 애플리케이션이 Sending to Remote상태로 변하게 된다. Sending to Remote에서는 다시 
  RemoteStore로 연동요청에 대한 ACK와 함께 애플리케이션을 보낸다. 이렇게 되면 RemoteStore에서
  ACK를 받고나서 Received 상태로 이동한다. Received상태에서는 연동할 애플리케이션에 대해서 
  검수가 완료되면 Audited at Remote로 상태가 바뀌고 이때 거절당하면 final state인 Rejected 
  at Remote가 된다. 거절당하지 않고 통과하면 연동할 애플리케이션이 게시가 되어 Online at Remote
  상태로 가게 된다.-->
  </p>
  <p>
  When the message that implies the completion of interlock is sent to origin store while the application is in online at remote state, the application alters
  from sending to remote state to Transmitted state. Transmitted stage means the application is sent and available in remote store. 
  First of all, the application can turn into 3 different states; Updating, Invalidating, and Invalidated by store manager. 
  Invalidated by store manager is when application is inactivated by a store manager, and the developer changes the application 
  state to updating state to update the application in the remote store. In Updating state, when other store requests the update, 
  the update requesting message is sent to the remote store. Application in Online at remote state receives the message and goes 
  on to updating at remote state and goes back to online at remote state when the update is over. Also when the ACK about the 
  update completion is sent to origin store, the origin store restores the updating application to the transmitted state. 
  <!--이제 연동완료되었다는 메시지를 Online at Remote 상태에서 OriginStore로 보내게 되면 OriginStore는
   Sending to Remote에서 Transmitted 상태로 넘어가게 된다. Transmitted는 애플리케이션이 전송되어
   RemoteStore에서 유효하다는 의미이다. 우선 Updating, Invalidating, Invalidated by store manager로
   상태가 각각 바뀔 수 있다. Invalidated by store manager는 store manager에 의해 애플리케이션이 
   비활성화된 상태이다. 그리고 개발자가 RemoteStore의 애플리케이션을 업데이트하기 위해 Updating으로
   바뀌는데, Updating은 타 스토어에 애플리케이션 업데이트를 요청 중인 상태로써 RemoteStore로
   업데이트 요청 메시지가 보내어진다. Online at Remote 상태에 있던 애플리케이션은 그 메시지를
   받아서 Updating at Remote상태로 넘어가고 완료되면 다시 Online at Remote로 넘어간다. 그리고
   업데이트 완료에 대한 ACK를 Origin Store로 보내게 되면 OriginStore는 ACK를 받아서 Updating에
   있던 애플리케이션 상태를 다시 Transmitted로 되돌린다.-->
  </p>
  <p>
  If developer wants to stop posting the application, it changes into invalidating state which is the state when a 
  posting suspension message is sent to other stores. Remote store that received this message converts the state of 
  application from online at remote to invalid at remote and sends the message mentioning that the state conversion 
  is completed in the form of ACK. When ACK is received, the application’s state changes in to invalidated state and 
  it further undergoes alteration into 3 different states. Firstly, Updated in invalidated state is when the developer 
  updates the application which is invalid. The application remains in this state regardless of the repeated updates 
  unless it is valid. When the suspension is cleared, the application state changes into validating updated app in 
  invalidated state. Application updated in this available situation sends the message about the activation to the 
  remote store. When an application in invalid at remote state is updated, its state is altered to updated in invalidated 
  state at remote and as it got a message about it, it is converted in to online at remote state. Also, if the origin 
  store receives the ACK about this, the state changes from validating updated state app in invalidated state to transmitted state.          
    <!--다음으로 개발자가 RemoteStore의 애플리케이션을 게시중단하기 위해 Invalidating 상태로 바뀌는데, 
    Invalidating은 타 스토어에 애플리케이션 게시 중단을 요청 중인 상태로써 RemoteStore로 게시중단 
    메시지가 전송된다. 이것을 받은 RemoteStore는 Online at Remote 상태에 있던 애플리케이션을 
    Invalid at Remote 상태로 보내고 그것을 완료했다는 메시지를 OriginStore에 ACK로 보내게 된다. 
    ACK를 받게 되면 Invalidated로 상태가 바뀌고 여기서는 다시 3개의 상태로 변화할 수 있다. 먼저 
    Updated in invalidated state 상태는 개발자가 게시중단 상태에 있는 애플리케이션을 업데이트 
    했을 때 일어나는 변화로 게시중단을 해제하지 않는 이상 반복적으로 업데이트를 수행하면 그 상태에 
    머물러 있게 되고 해제를 했을 경우 Validating updated app in invalidated state 상태로 바뀐다. 
    이 상태에서 업데이트된 애플리케이션 활성화에 대한 메시지를 RemoteStore로 보내는데, Invalid at 
    Remote 상태에 있는 애플리케이션을 업데이트 했을 경우 Updated in invalidated state at Remote 상태
    로 가게되고, 그 메시지를 받았기 때문에 다시 Online at Remote로 상태가 바뀌게 된다. 역시 이것에 
    대한 ACK를 OriginStore가 받으면 Validating updated app in invalidated state상태에서 Transmitted 
    상태로 바뀌게 된다.-->
  </p>
  <p>
    Changing from Incalidated to Validateing app in invalidated state, The developer moves stop posting application
   by making vitalization. At this time, It send a message disabling an application to release to the RemoteStore.
   RemoteStore received this message back from Invalid a Remote to Online at Remote again. After returning, ACK to complete the activation 
   sends to OriginStore, OriginStore go in to the Transmitted State aboriginally.
   <!-- Invalidated에서 Validating app in invalidated state 상태로 바뀌는 것은 개발자가 게시 중단된 애플
   리케이션을 활성화해서 이동하는 것으로, 이때도 RemoteStore로 비활성화된 애플리케이션 해제하라는 
   메시지를 보내게 된다. 이 메시지를 받은 RemoteStore는 Invalid at Remote상태에서 다시 Online at 
   Remote로 복귀하게 된다. 복귀한 후에 활성화 완료 ACK를 OriginStore에 보내게 되면, OriginStore는 
   원래대로 Transmitted 상태로 가게 된다.-->
  </p>
  <p>
   Finally, if the developer delete an application state of Invalidated, It return to Removing state.
   Delete request message send to RemoteStore because they Removing is state of remove the requesting state the other stores.
   RemoteStore received this message, after delete the application of Invalid at Remote, changes Removed at Remote such as final state.
   Once this is done the ACK send to OriginStore, OriginStore received it move to Removed state such as final state.
  <!-- 마지막으로 Invalidated 상태에 있는 애플리케이션이 개발자가 삭제를 하면 Removing 상태로 바뀌게 된다. 
  Removing은 타 스토어에도 삭제 요청 중인 상태를 나타내기 때문에 삭제 요청 메시지를 RemoteStore로 
  보내게 된다. 이 메시지를 받는 RemoteStore는 Invalid at Remote 상태에 있는 애플리케이션을 삭제한 
  뒤, final state인 Removed at Remote 상태로 바꾼다. 이것이 완료되면 그에 대한 ACK를 OriginStore로 
  보내게 되고, 그것을 받은 OriginStore는 final state인 Removed 상태로 이동하게 된다. -->
  </p>
  </section>

     <section>
  <h3>Lifecycle Sequence Diagram</h3>
        <section>
        <h4>Application Linkage Scenario</h4>
        <center>
         <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649941/993232d6-5a46-11e3-8bc1-b09c54eaa573.png');">
        <img src="https://f.cloud.github.com/assets/5457979/1649941/993232d6-5a46-11e3-8bc1-b09c54eaa573.png" width="60%" height="50%"/></a>
        </center>
  <p>
　In 'Application Linkage Scenario', Developer Support OriginStore appear on the left side of the object
   and the 'App at Origin', and the status of the application in the right side RemoteStore App at Remote object will be represented.
   First, the application in conjunction OriginStore before posting Developer Suport to the interchange between the App at Origin takes place.
   And Submitted, Audited, Online at Origin last state change. When the request is in conjunction RemoteStore Sending to Romote state change. 
   And so it comes to pass RemoteSotre Received, Audited at Remote Online at Remote state after state changes.
　 Origin of sending a message that completes Trasmitted condition exist.
  </p>
  <!--먼저 연동시나리오에서는 왼쪽에 OriginStore 에서 나타낼 Developer Support와 App at Origin 오브젝트가 있고, 
  오른쪽에는RemoteStore에서 애플리케이션의 상태를 나타낼 App at Remote 오브젝트가 있다. 
　먼저 연동이 되기전에 OriginStore에서 애플리케이션 게시를 위해서 Developer Suport와 App at Origin 사이에 상호 
교환이 일어나면서 Submitted, Audited, 마지막으로 Online at Origin 상태로 바뀌게 된다. RemoteStore에서 연동요청이 
오면 Sending to Romote상태로 바뀌게 되고 이렇게 RemoteSotre로 전달이 오면 Received, Audited at Remote상태를 거쳐 
Online at Remote상태로 변하게 된다. 완료되었다는 메시지를 Origin으로 보내 Trasmitted 상태로 존재하게 된다. 
 -->
        </section>

        <section>
        <h3>Web Application Delete Scenario</h3>
        <center>
         <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649939/80f3e1ec-5a46-11e3-9fbb-8ae1989894a4.png');">
        <img src="https://f.cloud.github.com/assets/5457979/1649939/80f3e1ec-5a46-11e3-9fbb-8ae1989894a4.png" width="60%" height="50%"/></a>
        </center>
 <p>
    In 'Application Delete Scenario', App at Origin exists in a state of 'Invalidated' at first.
   The Storefront Removing a delete request comes to the state and then to the transfer process, 
   which is reached via a Remote, App at Remote Invalidated at Remote's status was initially after receiving the request, the state is changed to Removed at Remote.
   This transfer process is complete, the message is delivered to the Origin Removed state has changed.
 　<!--삭제 시나리오에서는 App at Origin의 상태가 Invalidated로 존재한다. 이때 Storefront로부터 삭제 요청이 
 오면 Removing 상태로 바뀌고 전달 과정을 거쳐 Remote에 도달하게 되는데, App at Remote의 상태는 초기
 에 Invalidated at Remote였다가 요청을 받은 후에 Removed at Remote로 상태가 바뀐다. 이 전달과정이 끝나면 
 메시지가 Origin으로 전달되어 Removed로 상태가 바뀌게 된다. -->
 </p>
        </section>

        <section> 
        <h3>Web Application Update Scenario</h3>
        <center>
         <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649936/687bc404-5a46-11e3-83ff-82058ae69e52.png');">
        <img src="https://f.cloud.github.com/assets/5457979/1649936/687bc404-5a46-11e3-83ff-82058ae69e52.png" width="60%" height="50%"/></a>
        </center>
 <p>
   In ‘Application Invalidation Scenario’, ‘App at Remote’ exists in a state of ‘Transmitted’ at first. After receiving a request for deactivation from ‘Storefront’, 
  it changes into a state of ‘Invalidating’ and transferred to ‘App at Remote’ following the transmitting procedure. In the stage of ‘App at Remote’, it exists in a state of 
  ‘Online at Remote’ at first, and it changes into a state of ‘Invalidated at Remote’ after receiving the request. After all, it goes back to ‘Origin’ and change status from ‘Invalidating’ to ‘Invalidated’.
     <!-- 업데이트 시나리오에서는 App at Origin의 상태가 Transmitted에 존재한다. 그러다가 Storefront로부터 업데이트
    요청을 받게 되면 Updating으로 상태가 바뀌게 되고 전달과정이 계속 진행되어 RemoteStore로 넘어오게 된다. 
    RemoteStore는 App at Remote가 Received 상태로 있다가 검수가 끝나면 Audited at Remote로 바뀐 다음, 업데이트를
    진행하여 Online at Remote 상태로 끝난다. 이 과정이 Remote에서 마무리되면 다시 OriginStore로 원래대로 돌아가서
    Updating 상태에 있는 App at Origin을 Transmitted 상태로 다시 되돌린다. -->
 </p>
        </section>

        <section> 
        <h3>Web Application Invalidation Scenario</h3>
        <center>
        <a href="javascript:imgPop('https://f.cloud.github.com/assets/5457979/1649935/5136d176-5a46-11e3-8c36-60003fe77f60.png');">
        <img src="https://f.cloud.github.com/assets/5457979/1649935/5136d176-5a46-11e3-8c36-60003fe77f60.png" width="60%" height="50%"/></a>
        </center>
 <p>
   In Web application stop posting Scenario, App at Origin exist Transmitted state in the beginning. At this time, 
  When it receive a disabled request, it changes Invalidating state.  After the transfer process it moves to App
  at Remote. In App at Remote, it is Online at Remote at the beginning and changes Invalidated at Remote state for
  request. Again, go back to the Origin, it changes from Invalidating state to Invalidated state.
 </p>
 <!--애플리케이션 게시 중단 시나리오는 처음에 App at Origin이 Transmitted 상태로 존재한다. 
 이때 Storefront로부터 비활성화 요청을 받으면 Invalidating 상태로 바뀌고 전달과정이 이루어진 
 뒤에는 App at Remote로 이동하게 된다. App at Remote에서는 초기에 Online at Remote였다가 요청을 받아서 
 Invalidated at Remote로 상태가 바뀌어 마무리되면 다시 Origin으로 되돌아가서 Invalidating 상태를 Invalidated 상태로 바꾸게 된다. -->
        </section>

  </section>

</section>

<section>
<h3>A References</h3>
<p>
[1] OMA, Telco's Application Store Draft Version 1.0 <a href="http://www.openmobilealliance.org">http://www.openmobilealliance.org</a> 2012.05.24
<p>
[2] Samsung Apps: <a href="http://www.samsungapps.com">http://www.samsungapps.com</a>
<p>
[3] LG SmartWorld: <a href="http://kr.lgworld.com">http://kr.lgworld.com</a> 
<p>
[4] Pantech Appsplay: <a href="http://appsplay.vegalive.co.kr">http://appsplay.vegalive.co.kr</a> 
<p>
[5] Amazon Appstore: <a href="http://www.amazon.com/appstore">http://www.amazon.com/appstore</a> 
<p>
[6] SK Telecom T Store: <a href="http://www.tstore.co.kr">http://www.tstore.co.kr</a>
<p> 
[7] KT Olleh Market: <a href="http://market.olleh.com">http://market.olleh.com</a>
<p> 
[8] LG U+ Appmarket: <a href="http://ozstore.uplus.co.kr">http://ozstore.uplus.co.kr</a> 
<p>
[9] Naver N Store: <a href="http://nstore.naver.com/appstore/android/home.nhn">http://nstore.naver.com/appstore/android/home.nhn</a> 
<p>
[10] Windows Marketplace: <a href="http://www.windowsphone.com/ko-KR/marketplace">http://www.windowsphone.com/ko-KR/marketplace</a> 
<p>
[11] RIM Blackberry App World: <a href="http://appworld.blackberry.com/webstore">http://appworld.blackberry.com/webstore</a> 
<p>
[12] Chrome web store: <a href="http://chrome.google.com/webstore">http://chrome.google.com/webstore</a> 
<p>
[13] Firefox Marketplace: <a href="https://marketplace.firefox.com/">https://marketplace.firefox.com/</a> 
<p>
[14] Facebook Appcenter: <a href="http://www.facebook.com/appcenter">http://www.facebook.com/appcenter</a> 
<p>
[15] Chrome Manifest: <a href="https://developer.chrome.com/apps/manifest.html#overview">https://developer.chrome.com/apps/manifest.html#overview</a> 
<p>
[16] Firefox Manifest: <a href="https://developer.mozilla.org/ko/docs/Apps/Manifest">https://developer.mozilla.org/ko/docs/Apps/Manifest</a> 
<p>
[17] Wiki Manifest Comparison: <a href="http://www.w3.org/community/webappstore/wiki/Manifest">http://www.w3.org/community/webappstore/wiki/Manifest</a> 
</p>
</section>

  </body>
</html>
